A


new thing I learned here that in dp there should be a return datatype as it store the value in dp accordingly 


Memoization approach:-

class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), -1));
        int sum;
        return helper(grid, 0, 0, dp);
    }
    int helper(vector<vector<int>>& grid, int x, int y, vector<vector<int>>& dp) {


        if (dp[x][y] != -1) {
            return dp[x][y];
        }

        if (x == grid.size() - 1 && y == grid[0].size() - 1) {
            return grid[x][y];
        }

        int right = INT_MAX; 
        int down = INT_MAX;

        if (x < grid.size() - 1)
            right = helper(grid, x + 1, y, dp);
        if (y < grid[0].size() - 1)
            down = helper(grid, x, y + 1, dp);

        return dp[x][y] = grid[x][y] + min(right,down);
    }
};



My wrong code:-

It was working but not using dp 


class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), -1));
        int sum;
        helper(grid, 0, 0, dp, 0);
        return dp[grid.size() - 1][grid[0].size() - 1];
    }
    void helper(vector<vector<int>>& grid, int x, int y,
                vector<vector<int>>& dp, int sum) {
        sum += grid[x][y];
        if (dp[x][y] != -1) {
            dp[x][y] = min(sum, dp[x][y]);
            sum = dp[x][y];
        }
        if (x == grid.size() - 1 && y == grid[0].size() - 1) {
            if (dp[x][y] != -1)
                dp[x][y] = min(sum, dp[x][y]);
            else
                dp[x][y] = sum;
            return;
        }
        if (x < grid.size() - 1)
            helper(grid, x + 1, y, dp, sum);
        if (y < grid[0].size() - 1)
            helper(grid, x, y + 1, dp, sum);
        dp[x][y] = sum;
    }
};





grid =
[
  [1, 1, 4],
  [3, 5, 2],
  [1, 1, 1]
]


Final dp:
[7, 8, 7]
[6, 7, 3]
[3, 2, 1]


So:

dp[2][2] = 1 → From bottom-right, cost is just its own value.
dp[2][1] = 2 → From here, you need 1 step right with value 1, so 1 (here) + 1 (next).
dp[0][0] = 7 → From start, min path cost is 7.