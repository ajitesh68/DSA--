B


Memoization is not the way we will do this problem as it usese recursion and here dp technique takes O(n2) + O(n) of recursion stack 
as well which brings TLE in some cases

Tabulation will be better here as it does not have recursion method 



Memoization:-

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int m = triangle.size();
        vector<vector<int>> dp(m);
        for (int i = 0; i < m; i++) {
            dp[i].resize(triangle[i].size(), -1);
        }
        return helper(triangle, dp, 0, 0);
    }

    int helper(vector<vector<int>>& triangle, vector<vector<int>>& dp, int x, int y) {
        int m = triangle.size();

        if (x == m - 1) return triangle[x][y];


        if (dp[x][y] != -1) return dp[x][y];

     
        int path1 = helper(triangle, dp, x + 1, y);
        int path2 = helper(triangle, dp, x + 1, y + 1);

       
        return dp[x][y] = triangle[x][y] + min(path1, path2);
    }
};



Tabulation:-

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int m = triangle.size();
        int n = triangle[0].size();
        vector<vector<int>> dp(m);
        for (int i = 0; i < m; i++) {
            dp[i] = vector<int>(triangle[i].size(), 0);
        }
        dp[m-1] = triangle[m-1];

        for (int i = m - 2; i >= 0; i--) {
            n = triangle[i].size();
            for (int j = 0; j < n; j++) {
                dp[i][j] = triangle[i][j] + min(dp[i + 1][j], dp[i + 1][j +1]);
            }
        }
        return dp[0][0];
    }
};

