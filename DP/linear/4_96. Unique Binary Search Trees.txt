B(60 min)


wasnt able to think about the right logic 

not even close 
I was thinking something like permutations , visited array or unique bst 
but It was really simple problem if you get to the point 


The overall logic:-

Pick a root:
For n nodes, try each number i (from 1…n) as the root.

Split nodes:
Left subtree gets i-1 nodes (all values < i).
Right subtree gets n-i nodes (all values > i).

Recursive subproblems:
Number of unique BSTs with root i = numTrees(i−1)×numTrees(n−i)
(multiply because left & right choices are independent).

Add all possibilities:
Sum over all roots:
dp[i−1]×dp[n−i]

Base cases:
dp[0] = 1 (empty tree counts as one possibility).
dp[1] = 1 (single node tree).




Tabulation:- 

class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);

        dp[0]=dp[1]=1;

        for(int i = 2;i<=n;i++){
            for(int j=1; j<=i; j++){
                dp[i] += dp[j-1] * dp[i-j];
            }
        }

        return dp[n];

    }
}; 


Memoization:-

class Solution {
public:
    int solve(int n, vector<int>& dp) {
        // Base cases
        if (n == 0 || n == 1) return 1;

        if (dp[n] != -1) return dp[n];

        int ans = 0;
        for (int i = 1; i <= n; i++) {
            int left = solve(i - 1, dp);
            int right = solve(n - i, dp);
            ans += left * right;
        }

        return dp[n] = ans;
    }

    int numTrees(int n) {
        vector<int> dp(n + 1, -1);
        return solve(n, dp);
    }
};



