A


this is a hard one 



CODE WITHOUT MEMOIZATION:-(WORKS BUT NOT FOR LARGE INPUTS)

class Solution {
public:
    bool canJump(vector<int> stones, int currpost, int lastJump) {

        if (currpost == stones[stones.size() - 1])
            return true;
        if (currpost > stones[stones.size() - 1])
            return false;

        if (find(stones.begin(), stones.end(), currpost) != stones.end()) {
            if(lastJump != 0){
               if(canJump(stones, currpost + lastJump - 1, lastJump - 1))
                  return true;
               if(canJump(stones, currpost + lastJump, lastJump))
                  return true;
            }
            if(canJump(stones, currpost + lastJump + 1, lastJump + 1))
              return true;
        } 
        return false;
    }
    bool canCross(vector<int>& stones) {
        int currpost = 0;
        int lastJump = 0;
        return canJump(stones, 0, 0);
    }
};



CODE AFTER MEMOIZATION:-
class Solution {
public:
    unordered_map<string, bool> dp;

    bool canJump(vector<int>& stones, int currpost, int lastJump) {
       
        if (currpost == stones[stones.size() - 1])
            return true;

        if (currpost > stones[stones.size() - 1])
            return false;

  
        string key = to_string(currpost) + "," + to_string(lastJump);
        if (dp.count(key)) return dp[key];

        if (find(stones.begin(), stones.end(), currpost) != stones.end()) {
            if (lastJump != 0) {
                if (canJump(stones, currpost + lastJump - 1, lastJump - 1))
                    return dp[key] = true;
                if (canJump(stones, currpost + lastJump, lastJump))
                    return dp[key] = true;
            }
            if (canJump(stones, currpost + lastJump + 1, lastJump + 1))
                return dp[key] = true;
        }

        return dp[key] = false;
    }

    bool canCross(vector<int>& stones) {
        return canJump(stones, 0, 0);
    }
};





2nd Approach MEMOIZATION:-(using set instead of string)
class Solution {
public:
    unordered_map<int, unordered_map<int, bool>> dp;
    unordered_set<int> stoneSet;

    bool canJump(int currpost, int lastJump) {
        if (currpost == *stoneSet.rbegin())  // last stone
            return true;
        if (dp[currpost].count(lastJump)) return dp[currpost][lastJump];

        if (stoneSet.count(currpost)) {
            if (lastJump > 0 && canJump(currpost + lastJump - 1, lastJump - 1))
                return dp[currpost][lastJump] = true;
            if (lastJump > 0 && canJump(currpost + lastJump, lastJump))
                return dp[currpost][lastJump] = true;
            if (canJump(currpost + lastJump + 1, lastJump + 1))
                return dp[currpost][lastJump] = true;
        }

        return dp[currpost][lastJump] = false;
    }

    bool canCross(vector<int>& stones) {
        for (int stone : stones)
            stoneSet.insert(stone);

        return canJump(0, 0);
    }
};
