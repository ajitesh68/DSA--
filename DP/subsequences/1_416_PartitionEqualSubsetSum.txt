B


But in subset problems, we only have pick or not pick.

Pick → add nums[i] to subsum.

Not pick → keep subsum unchanged.
❌ No need to subtract.





C++’s unordered_map cannot directly use pair<int,int> as a key unless you provide a custom hash function.
That’s why your code won’t compile as is.




Memoization check bug
You wrote:

if (dp[{index, subsum}] == true)
    return dp[{index,subsum}];


Problem: If the state was solved as false, you won’t return it (you only return when true).
✅ Fix: Always check count:

if (dp.count({index, subsum})) return dp[{index, subsum}];







NOT working:-(dont know why)
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int total_sum = 0;
        int subsum;
        map<pair<int,int>,bool> dp;
        for (int i = 0; i < nums.size(); i++) {
            total_sum += nums[i];
        }
        int index;
        return helper(nums, total_sum, 0, 0, dp);
    }
    bool helper(vector<int>& nums, int total_sum, int subsum, int index,
                map<pair<int,int>,bool>& dp) {
        if (total_sum - subsum == subsum) {
            return true;
        }
        if (index == nums.size())
            return false;

        if (dp.count({index, subsum})) return dp[{index, subsum}];

        bool pick = helper(nums, total_sum, subsum + nums[index], index + 1,dp);
        bool notpick = helper(nums, total_sum, subsum, index + 1, dp);

        return dp[{index,subsum}] = pick || notpick;
    }
};


working(Memoization):-
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int total = 0;
        for (int x : nums) total += x;

        if (total % 2 != 0) return false;
        int target = total / 2;

        map<pair<int,int>, bool> dp;
        return helper(0, 0, target, nums, dp);
    }

    bool helper(int index, int curr, int target, 
                vector<int>& nums, map<pair<int,int>, bool>& dp) {
        if (curr == target) return true;
        if (index == nums.size() || curr > target) return false;

        if (dp.count({index, curr})) return dp[{index, curr}];

        bool pick = helper(index + 1, curr + nums[index], target, nums, dp);
        bool notPick = helper(index + 1, curr, target, nums, dp);

        return dp[{index, curr}] = pick || notPick;
    }
};
