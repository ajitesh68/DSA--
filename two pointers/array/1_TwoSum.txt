A+



I did on own the main task was to do in less than 0(n2) found almost both approach (hashmap)and (2 pointer + sort)


class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        vector<pair<int, int>> v;

        for (int i = 0; i < n; i++) {
            v.push_back({nums[i], i});
        }

        sort(v.begin(), v.end());

        int i = 0, j = n - 1;
        while (i < j) {
            int sum = v[i].first + v[j].first;
            if (sum == target) {
                return {v[i].second, v[j].second};
            } else if (sum < target) {
                i++;
            } else {
                j--;
            }
        }

        return {};
    }
};




hashmap approach:-

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mpp;
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (mpp.count(complement)) {
                return {mpp[complement], i};
            }
            mpp[nums[i]] = i;
        }
        return {};
    }
};

