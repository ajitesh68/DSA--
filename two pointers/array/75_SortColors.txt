A

I was able to do in O(n) but it took extra space so I lost here but 

this could be easily solve by dutch map algo 

binary searching


optimal code:-
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int low =0;

        while(mid <= high)
        {
            if(nums[mid]==0){
                swap(nums[low],nums[mid]);
                low++;
                mid++;
            }
            else if(nums[mid]==1)
            {
                mid++;
            }
            else {
                swap(nums[mid],nums[high]);
                high--;
            }
        }
        for(int i:nums){
            cout << i;
        }
    }
};



my approach:-(it was also 2 pointer but took extra space)
             ( but somehow after taking extra space it gives 100% )

class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        vector<int> arr(n, 1);
        int i = 0, j = n - 1;

        for (int k = 0; k < n; ++k) {
            if (nums[k] == 0) {
                arr[i] = 0;
                i++;
            } else if (nums[k] == 2) {
                arr[j] = 2;
                j--;
            }
        }

        nums = arr;
    }
};





